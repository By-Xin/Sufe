# 数据结构

## 八、查找

### 基本概念和术语

- 查找表
- 关键字
- 主关键字
- 次关键字
- 平均查找长度

	- pi为出现第i个位置的概率，ci为查找第i个记录所需的比较次数

$$
ASL=\sum_{i=1}^n p_ic_i
$$

### 静态查找表

- 顺序查找表

	- 监视哨的作用

		- 查找所需的平均时间几乎可以减少一半

	- 平均查找长度

		- 

$$
ASL_s=nP_1+(n-1)P_2+...+2P_{n-1}+P_n
$$
		- 等概率下

			- 

$$
ASL_s=(n+1)/2
$$
			- 

$$
ASL_f=n+1
$$

		- 不等概率下

			- 出现概率越大的元素排在顺序表的越后面时的ASL_s最大
			- 故在分布未知下，可以将查找到的记录移动到末尾

- 二分查找

	- 概念

		- 在有序表中，小左大右

	- 适用条件

		- 顺序存储
		- 按照关键字有序

	- 非递归实现
	- 递归实现
	- 二分查找的判定树

		- 概念

			- 每个节点对应着有序表中的一个记录，节点的值为该记录在表中的位置

		- 内部节点与外部节点

	- 二分查找的平均查找长度

		- 若有n个节关键字，则判定树的外部节点有n+1个
		- n个节点的判定树的高度与n个节点的完全二叉树的高度相同

$$
h=1+(\log_2n 向下取整)=\log_2(n+1)向上取整
$$
		- 

$$
ASL_S=\frac1n\sum_{j=1}^h j2^{j-1}=\frac{n+1}n\log_2(n+1)-1
$$
		- 折半查找的平均性能与最坏性能接近

	- 二分查找的最多/失败比较次数

		- 成功时

			- 

$$
\log_2(n+1)向上取整
$$

		- 失败时

			- 

$$
\log_2(n+1)向上取整
$$

	- 链表不可以折半查找（不能随机存储），只能顺序结构
	- 注意

		- 折半查找的中点为向下取整，即在偶数情况下，为左侧的元素作为中点

### 动态查找表

- 二叉排序树 BST

	- 定义

		- 若左子树不空，则左子树上的所有节点的值均小于根节点的值
		- 若右子树不空，则右子树上的所有节点的值均大于根节点的值
		- 左右子树也是二叉排序树

	- 特点

		- 各个节点的关键字互不相同
		- 二叉树的中序遍历得到递增序列
		- 二叉查找树不唯一，但中序序列相同

	- BST的查找

		- 若空，则不成功，否则
		- 若给定值=节点，则成功
		- 若给定值>节点，则左子树递归查找
		- 若给定值<节点，则右子树递归查找

	- BST的插入

		- 若为空树，则插入根节点
		- 否则，插入节点必为一个新的叶子节点
		- 新插入的节点一定是查找不成功时，查找路径上的最后一个节点的左儿子或右儿子

	- BST的构造

		- 循环调用插入算法
		- 若输入的顺序按照关键字有序输入，则二叉树将退化为链表

	- BST的删除

		- 被删除的节点为叶子节点，则直接删除
		- 若被删除的节点只有左子树或右子树，则将该子树移动到被删除的节点位置
		- 若被删除的节点既有左子树又有右子树，则前驱节点代替删除节点，前驱节点的子树代替前驱

			- 
			- 这里的前驱为中序遍历中删除节点的前一个元素，即其左子树的最右下节点

	- BST的平均查找长度

		- 

$$
ASL_s=(\sum第i层内部节点数\times层数i)/节点总数n
$$
		- 其中外部节点为为了补足BST称为完全二叉树而需要加上的那些节点（查找失败的节点）

$$
ASL_f=(\sum第i层外部节点数\times层数i)/节点总数n
$$
		- 最坏情况：链表

$$
ASL_s=(n+1)/2
$$
		- 最优情况：平衡二叉树

$$
ASL_s=O(\log n )
$$

	- BST查找性能

		- 

$$
O(\log n ) \sim O(n)
$$
		- BST的平均高度

$$
O(\log_2 n )
$$
		- 综合平均时间复杂度

$$
O(\log n )
$$

- 平衡二叉树AVL

	- 特点

		- 左右子树深度之差不大于1
		- 根节点的左右子树仍然为AVL树

	- 节点的平衡因子

$$
h_L-h_R
$$

		- 只有可能是-1, 1, 0之一

	- AVL树的ASL可保持在

$$
O(\log n )
$$
	- AVL的构造

		- 最小不平衡子树
		- 调整规律

			- RR

				- 左旋

			- LL

				- 右旋

			- LR

				- 先左后右

			- RL

				- 先右后左

	- AVL的删除

		- AVL的插入与删除是互逆的

			- 删除右子树导致失衡 = 在左子树进行插入导致失衡，LL或LR
			- 删除右子树导致失衡 = 在右子树进行插入导致失衡，RL或RR

		- 删除可能需要多次平衡

			- 平衡动作可能会导致祖先节点的不平衡

	- AVL的查找性能

		- AVL的查找过程与正常的二叉排序树相同，查找过程中和给定值进行比较的关键字个数不超过平衡树的深度
		- 最坏情况下，比较次数不超过树的高度
		- 含有n个节点的平衡二叉树能达到的最大深度

$$
h=\log _\psi(\sqrt5(n+1))-2, \psi=\frac{1+\sqrt 5}2
$$
		- 对于包含n个节点的AVL树的查找、插入、删除的时间复杂度

$$
O(\log n )
$$

	- 深度为h的平衡二叉树中含有的最少节点数：

$$
N_1=1, N_2=2, N_h=N_{h-1}+N_{h-2}+1
$$

		- 

- B树

	- m阶B树定义

		- 树中的每个节点最多有m颗子树
		- 若根节点不是叶子节点，则至少有两颗子树；
		- 除了根节点之外的所有非终端节点至少有 [m/2向上取整]颗子树
		- 所有非终端节点中包含下列数据

			- n为该节点中的关键字个数
			- K_i为关键字，i=1,2,...,n，且按i升序
			- A_i为指向子树根节点的指针，且A_i-1所指子树中所有节点的关键字均小于K_i，A_n所指子树中所有节点的关键字均大于K_n （左侧数据比节点小，右侧节点比根大）

		- 所有叶子节点在同一层，且不包含信息（可以认为是外部节点）

	- B树的查找
	- B树的插入

		- 插入的位置一定是最下层的非叶子节点

			- 若插入后数量不超过m，则不进行其他处理
			- 若插入后的关键字数量>=m，则需要进行分裂

				- 取中点（或m/2向上取整）
				- 原节点保留中点以前的节点
				- 新建节点，保留中点以后的节点
				- 中点节点本身上提到双亲节点

			- 若双亲为空，则新建双亲节点

		- B树节点中的关键字个数n必须满足

			- 

$$
m/2向上取整-1\leq n \leq m-1
$$

		- 插入的时候首先需要在最底层某个非终端节点添加一个关键字，若该节点的关键字个数超过m-1，则分裂节点，子树高度同时增长

	- 对于B树，其层数最多的构造方式为每个节点的关键字取1，构成一个完全二叉树，则层数h（不包括叶子层）

$$
h=\log_2(n+1)
$$
	- B树种的每个叶子节点对应一种查找失败，若B树有n个关键字，则B树对应着n+1种查找失败可能，其叶子节点个数为n+1
	- B树不支持顺序查找

- B+树

	- B+树的定义

		- 至多有m个子树
		- 根节点要么没有子树，要么至少有两颗子树
		- 除根节点之外的所有非终端节点至少有m/2向上取整个子树
		- 叶子节点都在最底层，包含了所有的关键字以及相应记录的指针，关键字大小顺序链接
		- 所有叶子节点包含全部的关键字以及指向相应记录的指针，且叶子节点按照关键字大小顺序连接
		- 所有分支节点中仅包含其各个子节点中最大的关键字即指向子节点的指针

	- B+树与B树的区别

		- 所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)
		- 为所有叶子结点增加了一个链指针

	- B+树的查找

		- 无论找到与否，需要一路一直确定到叶子节点为止

	- B+树的插入

		- 在某个叶子节点进行插入，若插入后的节点数量不超过m则完成，否则则需要进行分裂

	- m阶B+树中具有k个子树的节点有k个关键字

### 哈希表

- 概念

	- Hash: 关键字->地址
	- 好的哈希函数：对于关键字集合中的任意一个关键字，经过哈希函数映射到地址集合中任意一个地址的概率是等可能的（即均匀的哈希函数）
	- 主要问题

		- 均匀哈希
		- 冲突处理

			- 

$$
key1 \neq key2, H(key1)=H(key2)
$$

- 哈希函数

	- 直接定址法

		- 哈希函数为关键字的线性函数
		- 计算简单、不易冲突、空间易浪费

	- 数字分析法

		- 提取关键字中的部分位数的数字

	- 平方取中法

		- 取平方，再取字符中间的一段

	- 将关键字分割成若干部分，取其叠加和为哈希地址
	- 折叠法
	- 除留余数法

		- 其中p为不大于哈希表长m的整数

$$
H(key)=key\%p
$$
		- 关键是p的选择，一般情况下p为1.1n~1.7n范围内的一个素数时较为理想

- 解决冲突方法

	- 开放定址法

		- 从发生冲突的单元开始，按照一定次序，从哈希表中找出一个空闲的储存单元
		- 线性探测法

			- 从发生冲突的地址d开始，依次探测d的下一个地址（当到达Hash尾时，下一个探测的地址的表首地址为0），知道找出一个空表为止
			- 

$$
H_i(key)=(H(key)+i)\%m~(1\leq i\leq m-1)
$$
			- 优点：处理冲突的方式简单，不需要额外计算
缺点：容易成簇聚集，造成查找效率降低

		- 平方探测法

			- 若发生冲突的地址为d，则平方探测法的探测序列为d+1^2,d-1^2,d+2^2,d-2^2,...
			- 

$$
H_i(key)=(H(key)+d_i)\%m~(1\leq i\leq m-1),d_i=1^2,-1^2,2^2,-2^2,...
$$
			- 可以避免出现堆积问题，但不能探测到Hash表中的所有单元（至少能探测一半单元）

		- 伪随机探测

			- 通过伪随机数或双Hash函数进行探测
			- 

$$
（H_1key+i\times H_2(key))\%m(1 \leq i \leq m-1)
$$
			- 必须使H2(key)与m互素才能使发生冲突的同义词地址均匀分布在Hash表中

	- 再哈希法

		- 再哈希法同时构造多个不同的Hash函数
		- 我们将原哈希值l = H(key)加上另外一个哈希函数的值s(key)，再把相加后的结果放到原哈希函数里计算哈希值H(l + s(key))，然后看是否冲突，如不冲突就把元素存储到对应索引值的下方；如果还是冲突，就计算H(l + 2s(key))的值然后再判断，这样以此类推，直到不冲突为止。
		- 优点：再哈希后的值分散不聚集
缺点：需要做额外计算，如果再哈希的函数选择不好，可能会造成一直冲突

	- 链地址法

		- 链地址法（separate chaining）是将冲突的元素以链表的形式储存起来，具体来讲，具有相同的哈希地址的元素用节点的方式保存在链表的尾部。
		- 查找的时候，我们先计算查找元素的哈希值，然后从哈希表中找到对应的元素的值，如果值为空（None），那么就查找失败，如果不为空，那么就从链表里查找该元素。
		- 优点

			- 使用链地址法处理冲突无二次聚集现象，因此平均查找长度较短
			-  由于链地址法中各链表上的结点空间是动态申请的，因此适合于无法确定表长的情况； 
			- 在用链地址法构造的哈希表中，删除结点的操作易于实现，只要删除链表上相应的结点即可。

		- 缺点

			- 指针需要额外空间，故当记录规模较小时，开放定址法较为节省空间

	- 公共溢出区法

		- 为所有冲突的关键字记录建立一个公共的溢出区来存放。
		- 在查找时，对给定关键字通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表进行顺序查找。
		- 如果相对于基本表而言，在有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的

- 性能分析

	- 理论上的查找时间复杂度为O(1)
	- 查找性能的影响因素

		- Hash 函数
		- 冲突处理方法
		- 装填因子大小

			- 

$$
\alpha=表中元素个数/表长
$$

	- 线性探测再散列法

		- 成功时的平均查找长度
		- 失败时的平均查找长度

			- 判断流程

				- 首先根据H(key)将关键字从小到大排齐，中间可能出现NULL
				- 从下标0开始进行比较，一直到NULL为止（NULL也算一次比较），累计比较次数
				- 需要从0一直循环到m-1共m个元素，都要计数
				- 累计的比较次数和/m即为所求

		- 

$$
ASL\approx\frac12(1+\frac1{1-\alpha})
$$

	- 链地址法

		- 成功ASL
		- 失败ASL

## 七、图

### 定义与基本术语

- 图G=(V,E)

	- 有向图-弧

		- 有向完全图：有向图中，任意两个顶点之间都存在方向相反的两条弧

	- 无向图-边

		- 无向完全图：无向图，任意两个顶点之间存在连边

	- 稀疏图：弧或者边少
	- 子图

- 邻接点与关联边
- 顶点的度

	- 入度
	- 出度
	- 在有向图中，顶点的度=入度+出度
	- 

$$
边数=\frac12\sum_{i=1}^{节点总数}Degree(v_i)
$$

- 路径、回路、环

	- 路径
	- 有向路径
	- 回路/环
	- 路径长度：路径上的边或弧的数量称为路径的长度
	- 简单路径：顶点不重复出现的路径
	- 简单回路：除了第一个和最后一个顶点外，其余顶点不重复出现的回路

- 连通图与连通分量

	- 顶点的连通性
	- 连通图G

		- 在无向图G中，若任意两个顶点之间都是连通的，则G是连通图

	- 连通分量

		- 非连通图的极大连通子图称为连通分量

			- 含有极大顶点数
			- 依附于这些顶点的所有边

	- 强连通图

		- 在有向图G中，若每一对顶点从v到u和从u到v都存在路径，则G为强连通图

	- 强连通分量

		- 非强连通图的极大强连通子图为强连通分量

- 权、网

	- 带权图称为网

- 生成树

	- 包含图中的全部节点，但只有足以构成一棵树的n-1条边
	- 在生成树上添加一条边，必定构成一个环
	- 有n个顶点的生成树有且仅有n-1条边

		- 有n个顶点,<n-1条边的图: 非连通图
		- n个顶点，>n-1条边的图: 环

	- 但有n-1条边的图不一定是树

### 图的存储结构

- 邻接矩阵

	- 无向图的邻接矩阵

		- 主对角线为0且一定是对称矩阵

	- 有向图的邻接矩阵
	- 带权网的邻接矩阵

- 邻接表

	- 无向图的邻接表

		- 对于无向图的每个顶点vi，将所有与vi相邻的顶点链成一个单链表，称为顶点vi的边表或邻接表
		- 再把所有的边表的指针和顶点信息连接，构成顶点表
		- 空间需求：O(n+2e)

	- 有向图的邻接表

		- 正邻接表

			- 对于有向图的每个顶点vi，将节点指向的（邻接于vi）的所有顶点链接成一个单链表，称为顶点vi的出边表
			- 再把出边表中所有的指针和相关信息构成顶点表

		- 逆邻接表

			- 对于有向图中的每个节点vi，将指向vi（邻接到vi）的所有顶点链成一个单链表，称为vi的入边表
			- 再把入边表中所有的指针和相关信息构成顶点表

### 图的遍历

- 概念

	- 从图的某个顶点出发，访问图中的所有顶点，且每个顶点仅访问一次

- DepthFirstSearch 深度优先

	- 类似于树的先根遍历
	- 算法原理

		- 从图中某顶点v出发
		- 依次访问v的为访问的邻居节点，对图进行深度优先递归遍历；直到v的邻居都完成访问
		- 若图中仍有节点未被访问，则从一个未被访问的顶点出发，重新进行DFS遍历

	- v1-v2-v4-v8-v5-v3-v6-v7
	- 算法复杂度（假设n个顶点e个连边）

		- 邻接矩阵

			- 查找一个顶点的所有边用时：O(n)
			- 遍历图中所有顶点：O(n^2)
			- 适合边e多的图

		- 邻接表

			- 对于邻接表，共有2e个节点，因此扫描边的时间为O(e)
			- 每个顶点递归访问依次，所需时间为O(n+2e)=O(n+e)

- BreadFirstSearch 广度优先

	- 类似于树的层序遍历
	- 算法原理

		- 从某顶点vi出发，访问该节点
		- 访问该节点所有未被访问的邻居节点
		- 从这些邻居节点出发，防伪他们所有未被访问的邻居节点，直到所有的节点都被访问

	- v1-v2-v3-v4-v5-v6-v7-v8
	- 算法复杂度（假设n个顶点e个边）

		- 邻接矩阵

			- O(n^2)

		- 邻接表

			- O(n+e)

### 最小生成树

- 生成树

	- 一个连通图的生成树是一个极小连通子图，含有图中的全部顶点，但只有足以构成一颗树的n-1条边（无环）

- 生成树的代价

	- 各个边权重之和为该生成树的代价

- 最小生成树概念

	- 各边权重之和最小的生成树称为最小（代价）生成树

- 最小生成树的算法

	- Prim算法

		- 算法描述

			- 从一个顶点U={u0}作为初始状态，不断寻找与集合U中顶点相邻，且代价最小的边的邻居，直到扩充到全图为止

		- 

			- 

		- 算法复杂度

			- 时间复杂度

				- O(n^2)

			- 空间复杂度

				- O(n)

	- Kruskal算法

		- 算法描述

			- 在图中选择代价最小的边
			- 若该边依附的顶点落在不同的连通分量中，则采纳该边
			- 否则则舍弃，选择下一条代价最小的边（宗旨是不要生成回路）
			- 直到所有顶点都在同一连通分量上为止

		- 算法的时间复杂度

			- 适合边稀疏的情况

$$
O(e\log e)
$$

		- 

	- 破圈法

		- 算法描述

			- 循环以下步骤：
			- 在途中找到一个回路
			- 去掉该回路中权重最大的边

		- 思想简单，复杂度较高
		- 

- 有向无环图(Directed Acycline Graph)的应用

	- 概念

		- 可以描述一项工程或者系统的进行过程

	- Activity On Vertex 网

		- 概念

			- 用顶点表示子工程（或称活动）
			- 弧表示子工程之间的顺序关系

		- AOV网的特点

			- 不应该存在环

		- 拓扑排序

			- 概念

				- 将有向图中的顶点排成一个序列
				- 拓扑序列

					- 偏序
					- 全序

			- 拓扑排序算法

				- 在有向图中选择一个无前驱的顶点v（入度=0），输出
				- 从有向图中删除v与从v出发的弧
				- 重复上述操作，直到输出全部顶点，或图中不存在无前驱的顶点为止（此时存在环）
				- 
				- 有向图的拓扑排序不一定唯一
				- 复杂度分析（假设n个顶点e个边）

					- 初始寻找入度为0的顶点：O(n)；排序中，每个顶点入栈、出栈各一次，为O(n+e)；一共：O(n+e)

				- DAG图中，深度优先搜索遍历的逆序即为拓扑有序序列

	- Activity On Edge 网

		- 概念

			- 带权有向无环图，顶点表示事件（可以理解为状态），边表示活动，权重表示活动持续时间

		- 特点

			- 只有进入某一个顶点的各有向边代表的活动全部结束，该顶点所代表的事件才能发生
			- 只有在某个顶点所代表的事件发生以后，从该点出发的各有向边所代表的活动才能开始
			- 无回路
			- 只有一个入度=0的顶点，为源点，表示起点
			- 只有一个出度=0的顶点，为汇点，表示终点

		- 关键路径问题

			- 相关概念

				- 路径长度

					- 路径权重和，表示持续时间

				- 关键路径

					- 由于一些活动可以并行，因此完成工程的最短时间是从源点到汇点的最大路径长度；将这条路径称为关键路径（决速路径）
					- 关键路径可能不止一条

				- 关键活动

					- 概念

						- 关键路径上的活动称为关键活动

					- 相关计算

						- 事件Vj的最早发生时间ve(j)

							- Vj发生表示从Vj指出的活动可以开始
							- ve(j)=从源点到Vj的最长路径长度

						- 活动ai开始的最早时间e(i)

							- 设ai为Vj->Vk的边，则ei为从源点到Vj的最长路径长度
							- e(i)=ve(j)

						- 事件Vk的最迟发生事件vl(k)

							- 表示在不推迟工期的情况下，Vk允许的最迟开始时间
							- vl(k)=最长路径长度-顶点k到汇点的最长路径长度（后面的部分表示剩余的工作最快完成需要的时间）

						- 活动ai的最迟开始时间l(i)

							- 假设ai是Vj->Vk的边的活动
							- l(i)=vl(k)-ai的持续时间

						- 时间余量

							- l(i)-e(i)
							- 关键活动的l(i)=e(i)
							- 因此可以通过求解l(i),e(i)来确定关键活动

					- 利用拓扑排序算法确定关键路径和关键活动

						- 算法描述

							- 前进阶段

								- 从源点V1出发，令ve(1)=0，依次求出各个顶点的最早发生时间

$$
ve(k)=\max \{ve(j)+dut<j,k>\}
$$

							- 回退阶段

								- 从Vn出发，令vl(n)=ve(n)，按逆拓扑排序顺序求出各个顶点的最迟发生时间

$$
vl(j)=\min\{vl(k)-dut<j,k>\}
$$

							- 计算e(i),l(i)

								- 

$$
e(i)=ve(j),~l(i)=vl(k)-dut<j,k>
$$

							- 由e(i)=l(i)判断是否是关键活动

						- 

							- 

						- 算法分析

							- 时间复杂度

$$
O(n+e)
$$

						- 缩短关键活动是否必然缩短工期？

							- 不是任意关键活动都可以
							- 只有不改变关键路径的情况下，缩短才可以
							- 若同时存在几条关键路径，则必须同时提高才可以

### 最短路径

- Dijkstra算法：权值非负

	- 算法描述

		- 首先求出长度最短的一条路径，再参照它求出长度次短的路径，以此类推
		- 数据结构

			- V={V0,V1,...,Vn}

				- V0为出发点（源点）

			- G有向图，这里用邻接矩阵存储
			- D[i]：表示从源点到i节点的当前最短路径长度，若不连通则为inf
			- P[v][w]：为bool数组，TRUE表示从源点到v的路径上经过w
			- S[n]：存放已经采纳的集合S
			- final[n]：bool数组，表示顶点i的最短路径是否求出

		- 算法步骤

			- 1. 将V分为两个集合：S（已确定的集合），V-S（未确定的集合）
			- 2. 从V-S中选取一个顶点v，使得从S到V最小，把v加入S
			- 3. 调整D中记录的，从源点到V-S中每个顶点的最短距离

$$
\min(D[w],D[v]+G.arcs[v][w])
$$
			- 4. 重复2、3，直到包含V中的所有顶点

- Bellman-Ford算法：任意权重
- Floyd算法：所有顶点之间的最短路径

	- 若不存在负权重，则可以执行Dijkstra算法n次，复杂度为O(n^3)
	- Floyd算法思想

		- 若想从vi->vj，有可能直接的连边是最短的，也有可能是通过其他顶点间接到达是更短的，因此算法在路径中加入其他顶点，寻找是否有更短的情况

	- 数据结构

		- 图G由邻接矩阵进行存储
		- D[n][m]：存储最短路径长度，为广义邻接矩阵
		- P[v][w][u]：bool数组，若TRUE，表明v->w经过u

	- 算法过程

		- 先写出图的邻接矩阵D-1
		- 依次引入各个节点V0,V1,...,Vn作为中介节点
		- 每引入一个中介节点，考虑是否存在更短的中介路径
		- 引入下一个节点时保留上一步的D，在此基础上进行更新

	- 

		- 红色框选的部分对应的P矩阵为TRUE

## 九、排序

### 基本概念

- 排序的稳定性
- 内部排序与外部排序
- 排序方法的度量

	- 时间复杂度：考察数据的比较次数和数据的移动次数
	- 空间复杂性

- 待排序数据的结构：顺序存储

### 插入排序

- 概念

	- 将一个记录插入到已经排好顺序的序列中，形成一个新的，长度+1的有序序列

- 直接插入排序

	- 算法概述

		- 1. 将序列第一个记录认为是有序的子列
		- 2. 从第二个记录逐个进行插入，直到整个记录变成按关键字有序

	- 算法过程

		- 1. R[0]空出用作监视哨；认为R[1]目前为有序的，从R[2]开始遍历R[i] (i=2,...,n)
		- 2. 从R[i-1]开始向前推进，比较其与R[i]的大小，直到找到一个合适的位置k，使得R[k]>R[i] & R[k-1]<R[i]

	- 分析

		- 时间复杂度

			- 

$$
O(n^2)
$$

		- 空间复杂度

			- 只需要1个辅助单元（监视哨）

$$
O(1)
$$

		- 适用性

			- 适合元素数目少
			- 初始基本有序

		- 稳定

- 折半插入排序

	- 算法概述

		- 基本思路与直接插入相似，但是在插入时前半部分采用折半查找法

	- 分析

		- 折半插入减少了比较次数，移动次数不变
		- 时间复杂度

			- 

$$
O(n^2)
$$

		- 空间复杂度

			- 

$$
O(1)
$$

		- 稳定

- 2-路插入排序

	- 算法概述

		- 目的是减少移动次数，但需要n个辅助空间

	- 算法过程

		- 1. 首先申请n个大小的空间
		- 2. 将首个带排序关键字放在d[1]
		- 3. 后面的关键字若比d[1]大，则放在右边，否则则放在左边，放入时也要符合插入排序
		- 4. 直到final和first交汇，相当于d为环形数组

	- 分析

		- 时间复杂度

			- 

$$
O(n^2)
$$

		- 空间复杂度

			- 

$$
O(1)
$$

		- 稳定排序
		- 当首个关键字为最大值或最小值时，2-路插入失去优越性

- Shell‘s 排序

	- 缩小增量排序
	- 算法思想

		- 先将整个待排序元素分割成若干个小序列，每个子序列直接插入排序
		- 增加子序列长度，再次插入排序
		- 在整个序列基本有序的情况下，对全体元素再次插入排序

	- 
	- 分析

		- （按照建议的增量序列，最坏情况）时间复杂度

			- 

$$
O(n^2)
$$

		- 空间复杂度

			- 

$$
O(1)
$$

		- 不稳定排序 
		- 较为常用

### 交换排序

- 冒泡排序

	- 算法思想

		- 相邻位置的关键字进行比较，若顺序错误则交换
		- 通过比较使得元素中的最值上浮到序列一端，然后缩小排序范围
		- 若在一趟排序过程中没有任何交换，则整个排序过程终止

	- 分析

		- 时间复杂度

			- 

$$
O(n^2)
$$

		- 空间复杂度

			- 

$$
O(1)
$$

		- 稳定排序
		- 适合

			- 元素数目少
			- 初始基本有序

- 快速排序

	- 算法思想

		- 选取序列中的某个元素作为枢轴pivot（一般取第一个元素）
		- 通过一趟划分将待排序的序列分为左右两个子序列

			- 左子序列元素不大于pivot，右子序列不小于pivot

		- 分别对左右子序列再次进行快排

	- 算法步骤

		- 先将第一个元素提出作为pivot，原先的位置设为null
		- 数列的头作为low，尾作为high
		- low-> null，故只需要比较high与pivot的大小

			- 若high>=pivot

				- high--

			- 若high<pivot

				- high的值与low的值交换

		- 指null的指针不动，另一个指针继续移动比较，直到high=low，最后null=pivot

### 选择排序

### 归并排序

### 基数排序

### 内部排序方法的比较

