Yt[1] <- et[1]-theta*0
for(i in 2:(n+offset)){
Yt[i] <- et[i]-theta*et[i-1]
}
Yt <- Yt[(offset+1):(offset+n)]
mme <- ma1.mme(Yt)
cat(paste("MME result:",mme,"\n"))
cat(paste("CSS result:",arima(Yt, order = c(0,0,1), method = 'CSS')$coef[1],"\n"))
cat(paste("MLE result:",arima(Yt, order = c(0,0,1), method = 'ML')$coef[1],"\n"))
set.seed(5)
offset <- 300
n <- 36
theta <- -0.6
et <- rnorm(n+offset)
Yt <- NULL
Yt[1] <- et[1]-theta*0
for(i in 2:(n+offset)){
Yt[i] <- et[i]-theta*et[i-1]
}
Yt <- Yt[(offset+1):(offset+n)]
mme <- ma1.mme(Yt)
cat(paste("MME result:",mme,"\n"))
cat(paste("CSS result:",-arima(Yt, order = c(0,0,1), method = 'CSS')$coef[1],"\n"))
cat(paste("MLE result:",-arima(Yt, order = c(0,0,1), method = 'ML')$coef[1],"\n"))
set.seed(5)
offset <- 300
n <- 36
theta <- -0.6
et <- rnorm(n+offset)
Yt <- NULL
Yt[1] <- et[1]-theta*0
for(i in 2:(n+offset)){
Yt[i] <- et[i]-theta*et[i-1]
}
Yt <- Yt[(offset+1):(offset+n)]
mme <- ma1.mme(Yt)
cat(paste("MME result:",mme,"\n"))
cat(paste("CSS result:",-arima(Yt, order = c(0,0,1), method = 'CSS')$coef[1],"\n"))
cat(paste("MLE result:",-arima(Yt, order = c(0,0,1), method = 'ML')$coef[1],"\n"))
cat(paste("CSS result:",-arima(Yt, order = c(0,0,1), method = 'CSS'),"\n"))
cat(paste("CSS result:",-arima(Yt, order = c(0,0,1), method = 'CSS')$coef[1:2],,"\n"))
cat(paste("CSS result:",-arima(Yt, order = c(0,0,1), method = 'CSS')$coef[1:2],"\n"))
set.seed(5)
offset <- 300
n <- 36
theta <- -0.6
et <- rnorm(n+offset)
Yt <- NULL
Yt[1] <- et[1]-theta*0
for(i in 2:(n+offset)){
Yt[i] <- et[i]-theta*et[i-1]
}
Yt <- Yt[(offset+1):(offset+n)]
mme <- ma1.mme(Yt)
cat(paste("MME result:",mme,"\n"))
cat(paste("CSS result:",-arima(Yt, order = c(0,0,1), method = 'CSS')$coef[1:2],"\n"))
cat(paste("MLE result:",-arima(Yt, order = c(0,0,1), method = 'ML')$coef[1],"\n"))
arima(Yt, order = c(0,0,1), method = 'CSS')$coef[1]
arima(Yt, order = c(0,0,1), method = 'CSS')$coef[2]
arima(Yt, order = c(0,0,1), method = 'CSS')$coef[3]
arima(Yt, order = c(0,0,1), method = 'CSS')
Yt_css <- arima(Yt, order = c(0,0,1), method = 'CSS')
View(Yt_css)
set.seed(5)
offset <- 300
n <- 36
theta <- -0.6
et <- rnorm(n+offset)
Yt <- NULL
Yt[1] <- et[1]-theta*0
for(i in 2:(n+offset)){
Yt[i] <- et[i]-theta*et[i-1]
}
Yt <- Yt[(offset+1):(offset+n)]
mme <- ma1.mme(Yt)
print("MME result:")
mme
print("CSS result:")
arima(Yt, order = c(0,0,1), method = 'CSS')
print("MLE result:")
arima(Yt, order = c(0,0,1), method = 'ML')
set.seed(5)
offset <- 300
n <- 36
theta <- -0.6
et <- rnorm(n+offset)
Yt <- NULL
Yt[1] <- et[1]-theta*0
for(i in 2:(n+offset)){
Yt[i] <- et[i]-theta*et[i-1]
}
Yt <- Yt[(offset+1):(offset+n)]
mme <- ma1.mme(Yt)
print("MME result:")
mme
print("\n CSS result:")
arima(Yt, order = c(0,0,1), method = 'CSS')
print("\n MLE result:")
arima(Yt, order = c(0,0,1), method = 'ML')
set.seed(5)
offset <- 300
n <- 36
theta <- -0.6
et <- rnorm(n+offset)
Yt <- NULL
Yt[1] <- et[1]-theta*0
for(i in 2:(n+offset)){
Yt[i] <- et[i]-theta*et[i-1]
}
Yt <- Yt[(offset+1):(offset+n)]
mme <- ma1.mme(Yt)
print("MME result:")
mme
print(\n)
set.seed(5)
offset <- 300
n <- 36
theta <- -0.6
et <- rnorm(n+offset)
Yt <- NULL
Yt[1] <- et[1]-theta*0
for(i in 2:(n+offset)){
Yt[i] <- et[i]-theta*et[i-1]
}
Yt <- Yt[(offset+1):(offset+n)]
mme <- ma1.mme(Yt)
print("MME result:")
mme
print("\n")
print("CSS result:")
arima(Yt, order = c(0,0,1), method = 'CSS')
print("MLE result:")
arima(Yt, order = c(0,0,1), method = 'ML')
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 300
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
arima(Zt,order=c(1,0,1),method='CSS')
arima(Zt,order=c(1,0,1),method='ML')
knitr::opts_chunk$set(echo = TRUE)
acf(Zt)
acf(Zt,plot=FALSE)
r <- acf(Zt,plot=FALSE)
View(r)
rho1 <- acf(Zt,plot=FALSE)$lag[1]
rho1 <- acf(Zt,plot=FALSE)$l
rho1 <- acf(Zt,plot=FALSE)
View(rho1)
rho1 <- acf(Zt,plot=FALSE)$acf[1]
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
phi_hat <- rho2/rho2
phi_hat <- rho2/rho1
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
result <- uniroot(f,c(0,1))
result <- uniroot(func,c(0,1))
View(result)
result <- uniroot(func,c(0,1),tol=0.0001)
uniroot(func,c(0,1),tol=0.0001)
uniroot(func,c(0,1),tol=0.00001)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
2^2
?var
# sigma_e MME:
SigmaESquare_hat <- (1-\phi_hat^2)*var(Zt)/(1-2*phi_hat*theta_hat+theta_hat^2)
# sigma_e MME:
SigmaESquare_hat <- (1-phi_hat^2)*var(Zt)/(1-2*phi_hat*theta_hat+theta_hat^2)
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat)
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
cat("theta's MME:",theta_hat)
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,\n)
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
cat("theta's MME:",theta_hat)
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 200
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 300
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
cat("theta's MME:",theta_hat)
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 400
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
cat("theta's MME:",theta_hat)
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 300
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
cat("theta's MME:",theta_hat)
arima(Zt,order=c(1,0,1),method='CSS')
arima(Zt,order=c(1,0,1),method='ML')
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 400
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 400
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 400
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
cat("theta's MME:",theta_hat)
arima(Zt,order=c(1,0,1),method='CSS')
arima(Zt,order=c(1,0,1),method='ML')
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 300
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
cat("theta's MME:",theta_hat)
arima(Zt,order=c(1,0,1),method='CSS')
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 200
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 400
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
cat("theta's MME:",theta_hat)
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(1)
offset <- 300
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
cat("theta's MME:",theta_hat)
arima(Zt,order=c(1,0,1),method='CSS')
arima(Zt,order=c(1,0,1),method='ML')
# Z_t=0.7Z_t-1 + a_t - 0.4a_t-1
#library(TSA)
set.seed(5)
offset <- 300
n <- 72
theta <- 0.4
phi <- 0.7
at <- rnorm(n+offset)
Zt <- NULL
Zt[1] <- at[1]-theta*0
for(i in 2:(n+offset)){
Zt[i] <- at[i]-theta*at[i-1]+phi*Zt[i-1]
}
Zt <- Zt[(offset+1):(offset+n)]
plot(Zt, type = 'o', main = "", xlab = "t", ylab = expression(Z[t]))
rho1 <- acf(Zt,plot=FALSE)$acf[2]
rho2 <- acf(Zt,plot=FALSE)$acf[3]
# phi MME:
phi_hat <- rho2/rho1
cat("phi's MME: ",phi_hat,"\n")
# solve the eqn to get theta_hat MME, note that only keep the reversable solution.
func <- function(theta) rho1 - (1-theta*phi_hat)*(phi_hat-theta)/(1-2*theta*phi_hat+theta*theta)
theta_hat <- uniroot(func,c(0,1),tol=0.00001)$root
cat("theta's MME:",theta_hat)
#CSS
arima(Zt,order=c(1,0,1),method='CSS')
#MLE
arima(Zt,order=c(1,0,1),method='ML')
data("robot")
head(robot)
data("robot")
head(robot)
head("robot")
library(TSA)
data("robot")
view(robot)
print(robot)
plot(robot)
plot(robot, type = 'o', main = "", xlab = "t", ylab = robot)
plot(robot, type = 'o', xlab = "t", ylab = robot)
plot(robot, xlab = "t", ylab = robot)
plot(robot)
plot(robot,type='o')
arima(robot,order=c(1,0,0),method='CSS')
arima(robot,order=c(0,1,1),method='CSS')
arima(robot,order=c(0,1,1),method='CSS',AIC=TRUE)
arima(robot,order=c(0,1,1),method='CSS')
?arima
arima(robot,order=c(0,1,1),method='CSS')
arima(robot,order=c(0,1,1),method='CSS')$AIC
arima(robot,order=c(0,1,1),method='CSS')
temp <- arima(robot,order=c(0,1,1),method='CSS')
temp
View(temp)
arima(robot,order=c(1,0,0),method='CSS')$AIC
arima(robot,order=c(1,0,0),method='ML')
temp <- arima(robot,order=c(0,1,1),method='ML')
**(a) 对robot 序列建立AR(1) 模型，并估计其参数；**
arima(robot,order=c(0,1,1),method='ML')
